# coding: utf-8

"""
    Webhook Event Receiver API

    This API describes the event webhook calling convention. In order to receive webhook events from the gridX API, third parties must implement endpoints according to this specification. In the following, the external partner API is referred to as  \"external API\", while the gridX API is called \"gridX\". 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic import BaseModel, Field, StrictStr, validator

class InverterEventData(BaseModel):
    """
    Payload for `inverter/*` events. The event describes the change of an inverter from one status to a new one. The old status is referred to as the lastStatus.   # noqa: E501
    """
    appliance_id: StrictStr = Field(..., alias="applianceID", description="ID of the appliance that caused this event.")
    gateway_id: StrictStr = Field(..., alias="gatewayID", description="The ID of the gateway that connects to the appliance.")
    model: Optional[StrictStr] = Field(None, description="Model description of the appliance.")
    manufacturer: Optional[StrictStr] = Field(None, description="Manufacturer of the appliance.")
    type: Optional[StrictStr] = Field(None, description="General type of the appliance.")
    kind: Optional[StrictStr] = Field(None, description="Kind of the appliance is used to provide further details on the appliance configuration and mode of operation. The kind property is only available for appliances with type INVERTER or METER. For inverters, only UNKNOWN, PV, BATTERY, HYBRID and PV_EXTERNAL are valid values. They describe the  kind of connected appliance(s) and define the role of the inverter in the system. For meters, kind specifies the appliance the meter is attached to. It resembles the location the meter is installed in. ")
    name: Optional[StrictStr] = Field(None, description="The name of the appliance as defined by the customer.")
    serial_number: Optional[StrictStr] = Field(None, alias="serialNumber", description="Serial number of the appliance as returned by the appliance.")
    system_id: StrictStr = Field(..., alias="systemID", description="The ID of the system that the gateway and appliance run in.")
    system_name: Optional[StrictStr] = Field(None, alias="systemName", description="Name of the system as defined by the customer.")
    status: StrictStr = Field(..., description="Current (new) status of the inverter.")
    last_status: StrictStr = Field(..., alias="lastStatus", description="Last status of the inverter.")
    err_code: Optional[StrictStr] = Field(None, alias="errCode", description="Current (new) error code as returned by the appliance. The value depends on the appliance manufacturer, model and firmware. Please refer to the manufacturers specification. ")
    last_err_code: Optional[StrictStr] = Field(None, alias="lastErrCode", description="Last error code as returned by the appliance. The value depends on the appliance manufacturer, model and firmware. Please refer to the manufacturers specification. ")
    __properties = ["applianceID", "gatewayID", "model", "manufacturer", "type", "kind", "name", "serialNumber", "systemID", "systemName", "status", "lastStatus", "errCode", "lastErrCode"]

    @validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('UNKNOWN', 'INVERTER', 'METER', 'EVSTATION', 'HEAT_PUMP', 'HEATER', 'CONTAINER'):
            raise ValueError("must be one of enum values ('UNKNOWN', 'INVERTER', 'METER', 'EVSTATION', 'HEAT_PUMP', 'HEATER', 'CONTAINER')")
        return value

    @validator('kind')
    def kind_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('UNKNOWN', 'PV', 'BATTERY', 'HYBRID', 'PV_EXTERNAL', 'GRID', 'HEAT_PUMP', 'FUEL_CELL', 'HEAT_PUMP_EXTERNAL', 'EVSTATION', 'BTTP', 'HEATING', 'MISC', 'CLUSTER', 'WIND_TURBINE'):
            raise ValueError("must be one of enum values ('UNKNOWN', 'PV', 'BATTERY', 'HYBRID', 'PV_EXTERNAL', 'GRID', 'HEAT_PUMP', 'FUEL_CELL', 'HEAT_PUMP_EXTERNAL', 'EVSTATION', 'BTTP', 'HEATING', 'MISC', 'CLUSTER', 'WIND_TURBINE')")
        return value

    @validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('UNKNOWN', 'OK', 'WARNING', 'ERROR'):
            raise ValueError("must be one of enum values ('UNKNOWN', 'OK', 'WARNING', 'ERROR')")
        return value

    @validator('last_status')
    def last_status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('UNKNOWN', 'OK', 'WARNING', 'ERROR'):
            raise ValueError("must be one of enum values ('UNKNOWN', 'OK', 'WARNING', 'ERROR')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> InverterEventData:
        """Create an instance of InverterEventData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> InverterEventData:
        """Create an instance of InverterEventData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return InverterEventData.parse_obj(obj)

        _obj = InverterEventData.parse_obj({
            "appliance_id": obj.get("applianceID"),
            "gateway_id": obj.get("gatewayID"),
            "model": obj.get("model"),
            "manufacturer": obj.get("manufacturer"),
            "type": obj.get("type"),
            "kind": obj.get("kind"),
            "name": obj.get("name"),
            "serial_number": obj.get("serialNumber"),
            "system_id": obj.get("systemID"),
            "system_name": obj.get("systemName"),
            "status": obj.get("status"),
            "last_status": obj.get("lastStatus"),
            "err_code": obj.get("errCode"),
            "last_err_code": obj.get("lastErrCode")
        })
        return _obj


